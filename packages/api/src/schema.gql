# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

input AddressCardCreateInput {
  auth_type: String
  email: String
  evm_address: String
  merchant_id: String
  social_id: String
}

input AddressCardOrderByWithRelationInput {
  auth_type: SortOrder
  email: SortOrder
  evm_address: SortOrder
  id: SortOrder
  merchant_id: SortOrder
  social_id: SortOrder
}

enum AddressCardScalarFieldEnum {
  auth_type
  createdAt
  email
  evm_address
  id
  merchant_id
  social_id
  updatedAt
}

input AddressCardWhereInput {
  AND: [AddressCardWhereInput!]
  NOT: [AddressCardWhereInput!]
  OR: [AddressCardWhereInput!]
  auth_type: StringFilter
  email: StringFilter
  evm_address: StringFilter
  id: IntFilter
  merchant_id: StringFilter
  social_id: StringFilter
}

input AddressCardWhereUniqueInput {
  id: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

type Mutation {
  """."""
  upsertAddressCard(data: AddressCardCreateInput!): Response!

  """."""
  upsertProject(data: ProjectCreateInput!): Response!

  """."""
  upsertUser(data: UserCreateInput!): Response!
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input ProjectCreateInput {
  carry_over_balance: Int
  contributor_count: Int
  credit_amount: Int
  name: String!
  picture: String
  price_coefficient: Int
  project_id: String!
  service_id: String!
  ticket_count_closed: Int
  ticket_count_total: Int
  total_claimed: Int
}

input ProjectOrderByWithRelationInput {
  carry_over_balance: SortOrder
  contributor_count: SortOrder
  credit_amount: SortOrder
  id: SortOrder
  name: SortOrder
  picture: SortOrder
  price_coefficient: SortOrder
  project_id: SortOrder
  service_id: SortOrder
  ticket_count_closed: SortOrder
  ticket_count_total: SortOrder
  total_claimed: SortOrder
}

enum ProjectScalarFieldEnum {
  carry_over_balance
  contributor_count
  created_at
  credit_amount
  id
  name
  picture
  price_coefficient
  project_id
  service_id
  ticket_count_closed
  ticket_count_total
  total_claimed
  updated_at
}

input ProjectWhereInput {
  AND: [ProjectWhereInput!]
  NOT: [ProjectWhereInput!]
  OR: [ProjectWhereInput!]
  carry_over_balance: IntFilter
  contributor_count: IntFilter
  credit_amount: IntFilter
  id: IntFilter
  name: StringFilter
  picture: StringFilter
  price_coefficient: IntFilter
  project_id: StringFilter
  service_id: StringFilter
  ticket_count_closed: IntFilter
  ticket_count_total: IntFilter
  total_claimed: IntFilter
}

input ProjectWhereUniqueInput {
  id: Int
}

type Query {
  """."""
  findAddressCard(cursor: AddressCardWhereUniqueInput, distinct: [AddressCardScalarFieldEnum!], orderBy: [AddressCardOrderByWithRelationInput!], skip: Int, take: Int, where: AddressCardWhereInput): Response!

  """."""
  findManyAddressCard(cursor: AddressCardWhereUniqueInput, distinct: [AddressCardScalarFieldEnum!], orderBy: [AddressCardOrderByWithRelationInput!], skip: Int, take: Int, where: AddressCardWhereInput): Response!

  """."""
  findManyProject(cursor: ProjectWhereUniqueInput, distinct: [ProjectScalarFieldEnum!], orderBy: [ProjectOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectWhereInput): Response!

  """."""
  findManyUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!

  """."""
  findUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): Response!
}

type Response {
  response: JSON
}

enum SortOrder {
  asc
  desc
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type User {
  address1: String!
  address2: String!
  address3: String!
  address4: String!
  auth_type: String!
  email: String!
  first_name: String!
  id: ID!
  last_name: String!
  name: String!
  social_id: String!
  tel: String!
  user_id: String!
  zip1: String!
  zip2: String!
}

input UserCreateInput {
  address1: String
  address2: String
  address3: String
  address4: String
  auth_type: String
  email: String
  first_name: String
  last_name: String
  name: String
  password: String
  social_id: String
  tel: String
  user_id: String
  zip1: String
  zip2: String
}

input UserOrderByWithRelationInput {
  address1: SortOrder
  address2: SortOrder
  address3: SortOrder
  address4: SortOrder
  auth_type: SortOrder
  email: SortOrder
  first_name: SortOrder
  id: SortOrder
  last_name: SortOrder
  name: SortOrder
  password: SortOrder
  social_id: SortOrder
  tel: SortOrder
  user_id: SortOrder
  zip1: SortOrder
  zip2: SortOrder
}

enum UserScalarFieldEnum {
  address1
  address2
  address3
  address4
  auth_type
  createdAt
  email
  first_name
  id
  last_name
  name
  password
  social_id
  tel
  updatedAt
  user_id
  zip1
  zip2
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  address1: StringFilter
  address2: StringFilter
  address3: StringFilter
  address4: StringFilter
  auth_type: StringFilter
  email: StringFilter
  first_name: StringFilter
  id: IntFilter
  last_name: StringFilter
  name: StringFilter
  password: StringNullableFilter
  social_id: StringFilter
  tel: StringFilter
  user_id: StringFilter
  zip1: StringFilter
  zip2: StringFilter
}

input UserWhereUniqueInput {
  id: Int
  user_id: String
}